use std::io::{self, Write};

use crate::rules::Diagnostic;

/// Generate a markdown summary for PR comments
pub fn generate_pr_comment(diagnostics: &[Diagnostic]) -> String {
    let error_count = diagnostics
        .iter()
        .filter(|d| matches!(d.severity, crate::rules::Severity::Error))
        .count();
    let warning_count = diagnostics
        .iter()
        .filter(|d| matches!(d.severity, crate::rules::Severity::Warning))
        .count();

    let mut output = String::new();

    // Header with badge
    if error_count == 0 && warning_count == 0 {
        output.push_str("## ‚úÖ envcheck: All checks passed\n\n");
        output.push_str("No issues found in environment files.\n");
        return output;
    }

    if error_count > 0 {
        output.push_str(&format!(
            "## ‚ùå envcheck: {error_count} error(s), {warning_count} warning(s)\n\n"
        ));
    } else {
        output.push_str(&format!("## ‚ö†Ô∏è envcheck: {warning_count} warning(s)\n\n"));
    }

    // Summary table
    output.push_str("| File | Line | Severity | Rule | Message |\n");
    output.push_str("|------|------|----------|------|--------|\n");

    for d in diagnostics {
        let severity = match d.severity {
            crate::rules::Severity::Error => "üî¥ Error",
            crate::rules::Severity::Warning => "üü° Warning",
            crate::rules::Severity::Info => "üîµ Info",
        };

        let file = d
            .path
            .file_name()
            .map(|n| n.to_string_lossy())
            .unwrap_or_default();
        let line = d.line.map_or_else(|| "-".to_string(), |l| l.to_string());

        output.push_str(&format!(
            "| {} | {} | {} | {} | {} |\n",
            file, line, severity, d.id, d.message
        ));
    }

    output.push_str("\n---\n");
    output.push_str("*Generated by [envcheck](https://github.com/envcheck/envcheck)*\n");

    output
}

pub fn write_pr_comment(diagnostics: &[Diagnostic], writer: &mut dyn Write) -> io::Result<()> {
    let comment = generate_pr_comment(diagnostics);
    writeln!(writer, "{comment}")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::rules::{Diagnostic, RuleId, Severity};
    use std::path::PathBuf;

    #[test]
    fn test_pr_comment_no_issues() {
        let diagnostics: Vec<Diagnostic> = vec![];
        let comment = generate_pr_comment(&diagnostics);
        assert!(comment.contains("‚úÖ"));
        assert!(comment.contains("All checks passed"));
    }

    #[test]
    fn test_pr_comment_with_errors() {
        let diagnostics = vec![Diagnostic {
            id: RuleId::E001,
            severity: Severity::Error,
            message: "Duplicate key".to_string(),
            path: PathBuf::from(".env"),
            line: Some(5),
        }];
        let comment = generate_pr_comment(&diagnostics);
        assert!(comment.contains("‚ùå"));
        assert!(comment.contains("1 error"));
        assert!(comment.contains("E001"));
    }
}
